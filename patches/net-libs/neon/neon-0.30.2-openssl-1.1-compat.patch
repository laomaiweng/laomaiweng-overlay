diff --git a/src/ne_openssl.c b/src/ne_openssl.c
index e4d8db7..890e18c 100644
--- a/src/ne_openssl.c
+++ b/src/ne_openssl.c
@@ -70,6 +70,9 @@ typedef const unsigned char ne_d2i_uchar;
 #define X509_up_ref(x) x->references++
 #define EVP_PKEY_up_ref(x) x->references++
 #define EVP_PKEY_get0_RSA(evp) (evp->pkey.rsa)
+#else
+#define X509_get_notBefore X509_get0_notBefore
+#define X509_get_notAfter X509_get0_notAfter
 #endif
 
 struct ne_ssl_dname_s {
@@ -1160,6 +1163,7 @@ static unsigned long thread_id_neon(void)
 }
 #endif
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 /* Another great API design win for OpenSSL: no return value!  So if
  * the lock/unlock fails, all that can be done is to abort. */
 static void thread_lock_neon(int mode, int n, const char *file, int line)
@@ -1183,6 +1187,7 @@ static void thread_lock_neon(int mode, int n, const char *file, int line)
         }
     }
 }
+#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */
 
 #endif
 
@@ -1249,6 +1254,7 @@ int ne__ssl_init(void)
 
 void ne__ssl_exit(void)
 {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     /* Cannot call ERR_free_strings() etc here in case any other code
      * in the process using OpenSSL. */
 
@@ -1276,4 +1282,5 @@ void ne__ssl_exit(void)
         free(locks);
     }
 #endif
+#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */
 }
